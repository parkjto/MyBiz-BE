<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MyBiz ì±—ë´‡ í…ŒìŠ¤íŠ¸</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Noto Sans KR', 'Apple SD Gothic Neo', Arial, sans-serif; margin: 24px; background:#fafafa; color:#222 }
    h1 { font-size: 20px; margin: 0 0 16px }
    .card { background:#fff; border:1px solid #e5e7eb; border-radius:12px; padding:16px; margin-bottom:16px; box-shadow:0 1px 2px rgba(0,0,0,0.04) }
    label { display:block; font-size:12px; color:#666; margin-bottom:6px }
    input[type="text"], input[type="password"], textarea { width:100%; box-sizing:border-box; padding:10px 12px; border:1px solid #d1d5db; border-radius:8px; outline:none; font-size:14px; background:#fff }
    textarea { min-height: 80px }
    .row { display:flex; gap:12px; flex-wrap: wrap }
    .row .col { flex:1 1 240px }
    .btn { appearance:none; border:1px solid #111827; background:#111827; color:#fff; border-radius:8px; padding:10px 14px; font-size:14px; cursor:pointer }
    .btn.secondary { background:#fff; color:#111827 }
    .btn:disabled { opacity:0.5; cursor:not-allowed }
    .chips { display:flex; gap:8px; flex-wrap:wrap }
    .chip { padding:8px 10px; border:1px solid #d1d5db; border-radius:20px; font-size:13px; cursor:pointer; background:#fff }
    .chip:hover { background:#f3f4f6 }
    pre { background:#0b1020; color:#f3f4f6; padding:12px; border-radius:8px; overflow:auto; max-height:50vh; font-size:12px }
    .muted { color:#6b7280; font-size:12px }
  </style>
</head>
<body>
  <h1>ğŸ¤– MyBiz ì±—ë´‡ í…ŒìŠ¤íŠ¸</h1>

  <div class="card">
    <div class="row">
      <div class="col">
        <label>JWT í† í° (Authorization: Bearer ...)</label>
        <input id="token" type="password" placeholder="YOUR_JWT_TOKEN" />
        <div class="muted">ìƒíƒœ ì¡°íšŒëŠ” í† í° ë¶ˆí•„ìš”, ê·¸ ì™¸ ì—”ë“œí¬ì¸íŠ¸ëŠ” í† í° í•„ìš”</div>
      </div>
      <div class="col">
        <label>userId</label>
        <input id="userId" type="text" placeholder="ì˜ˆ: test_user_123" value="test_user" />
      </div>
    </div>
    <div style="margin-top:12px; display:flex; gap:8px">
      <button class="btn secondary" id="saveToken">í† í° ì €ì¥</button>
      <button class="btn secondary" id="clearToken">í† í° ì§€ìš°ê¸°</button>
      <span class="muted" id="tokenStatus"></span>
    </div>
  </div>

  <div class="card">
    <div class="row">
      <div class="col">
        <label>í…ìŠ¤íŠ¸ ë©”ì‹œì§€</label>
        <textarea id="message" placeholder="ì˜ˆ: ë§¤ì¶œ ë¶„ì„ì„ ë³´ì—¬ì£¼ì„¸ìš”"></textarea>
      </div>
    </div>
    <div class="chips" style="margin:10px 0 6px">
      <span class="chip" data-msg="ë§¤ì¶œ ë¶„ì„ì„ ë³´ì—¬ì£¼ì„¸ìš”">ë§¤ì¶œ ë¶„ì„</span>
      <span class="chip" data-msg="ë¦¬ë·° ìƒí™©ì„ í™•ì¸í•´ì¤˜">ë¦¬ë·° ë¶„ì„</span>
      <span class="chip" data-msg="ë§¤ì¶œì„ ì˜¬ë¦¬ëŠ” ë°©ë²•ì„ ì•Œë ¤ì¤˜">ë§¤ì¶œ ê°œì„  ë°©ì•ˆ</span>
      <span class="chip" data-msg="ê´‘ê³ ë¥¼ ë§Œë“¤ì–´ì¤˜">ê´‘ê³  ìƒì„±</span>
      <span class="chip" data-msg="ì•ˆë…•í•˜ì„¸ìš”">ì¼ë°˜ ëŒ€í™”</span>
    </div>
    <div style="display:flex; gap:8px; flex-wrap:wrap">
      <button class="btn" id="callStatus">ìƒíƒœ ì¡°íšŒ (GET /api/chatbot/status)</button>
      <button class="btn" id="callTestIntent">ì˜ë„ ë¶„ë¥˜ (POST /api/chatbot/test-intent)</button>
      <button class="btn" id="callMessage">ë©”ì‹œì§€ ì²˜ë¦¬ (POST /api/chatbot/message)</button>
    </div>
  </div>

  <div class="card">
    <label>ìŒì„± íŒŒì¼ ì—…ë¡œë“œ (ì„ íƒ)</label>
    <input id="audioFile" type="file" accept="audio/*" />
    <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap">
      <button class="btn" id="callVoice">ìŒì„± ëª…ë ¹ (POST /api/chatbot/voice)</button>
      <button class="btn secondary" id="wsStart">ì‹¤ì‹œê°„ ìŒì„± ì‹œì‘(WebSocket)</button>
      <button class="btn secondary" id="wsStop">ì¤‘ì§€</button>
      <span class="muted">mp3/wav ì—…ë¡œë“œ ë˜ëŠ” ë§ˆì´í¬ ì‹¤ì‹œê°„ ì „ì†¡</span>
    </div>
  </div>

  <div class="card">
    <div style="display:flex; justify-content:space-between; align-items:center">
      <strong>ì‘ë‹µ</strong>
      <span class="muted" id="navHint"></span>
    </div>
    <pre id="output">ì‘ë‹µì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</pre>
  </div>

  <script>
    const $ = (sel) => document.querySelector(sel);

    // ë¡œì»¬ ì €ì¥ëœ í† í° ë³µêµ¬
    const tokenInput = $('#token');
    const tokenStatus = $('#tokenStatus');
    const saved = localStorage.getItem('chatbot_token');
    if (saved) {
      tokenInput.value = saved;
      tokenStatus.textContent = 'ì €ì¥ëœ í† í° ì‚¬ìš© ì¤‘';
    }

    $('#saveToken').addEventListener('click', () => {
      const cleaned = tokenInput.value.replace(/\s+/g, '').trim();
      tokenInput.value = cleaned;
      localStorage.setItem('chatbot_token', cleaned);
      tokenStatus.textContent = `í† í° ì €ì¥ë¨ (len: ${cleaned.length})`;
    });
    $('#clearToken').addEventListener('click', () => {
      localStorage.removeItem('chatbot_token');
      tokenInput.value = '';
      tokenStatus.textContent = 'í† í° ì‚­ì œë¨';
    });

    // ë¹ ë¥¸ ë¬¸êµ¬ ì±„ìš°ê¸°
    document.querySelectorAll('.chip').forEach(chip => {
      chip.addEventListener('click', () => {
        $('#message').value = chip.dataset.msg;
      });
    });

    const setOutput = (obj) => {
      $('#output').textContent = typeof obj === 'string' ? obj : JSON.stringify(obj, null, 2);
    };

    const showNavHint = (resp) => {
      const hint = $('#navHint');
      if (resp && resp.data && resp.data.type === 'navigation') {
        hint.textContent = `í™”ë©´ ì´ë™: ${resp.data.screen}`;
      } else if (resp && resp.type === 'navigation') {
        hint.textContent = `í™”ë©´ ì´ë™: ${resp.screen}`;
      } else {
        hint.textContent = '';
      }
    };

    const buildHeaders = (needAuth = false) => {
      const headers = { 'Content-Type': 'application/json' };
      const t = tokenInput.value.replace(/\s+/g, '').trim();
      if (needAuth && t) headers['Authorization'] = `Bearer ${t}`;
      return headers;
    };

    // 1) ìƒíƒœ ì¡°íšŒ
    $('#callStatus').addEventListener('click', async () => {
      try {
        const res = await fetch('/api/chatbot/status');
        const data = await res.json();
        setOutput(data);
        showNavHint(data);
      } catch (e) {
        console.error('[callStatus] error', e);
        setOutput({ error: e.message });
      }
    });

    // 2) ì˜ë„ ë¶„ë¥˜
    $('#callTestIntent').addEventListener('click', async () => {
      const text = $('#message').value.trim();
      if (!text) return setOutput('í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.');
      try {
        const res = await fetch('/api/chatbot/test-intent', {
          method: 'POST',
          headers: buildHeaders(true),
          body: JSON.stringify({ text })
        });
        const data = await res.json();
        setOutput(data);
        showNavHint(data);
      } catch (e) {
        console.error('[callTestIntent] error', e);
        setOutput({ error: e.message });
      }
    });

    // 3) ë©”ì‹œì§€ ì²˜ë¦¬
    $('#callMessage').addEventListener('click', async () => {
      const text = $('#message').value.trim();
      const userId = $('#userId').value.trim() || 'test_user';
      if (!text) return setOutput('í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.');
      try {
        const res = await fetch('/api/chatbot/message', {
          method: 'POST',
          headers: buildHeaders(true),
          body: JSON.stringify({ text, userId })
        });
        const data = await res.json();
        setOutput(data);
        showNavHint(data);
      } catch (e) {
        console.error('[callMessage] error', e);
        setOutput({ error: e.message });
      }
    });

    // 4) ìŒì„± ëª…ë ¹ (íŒŒì¼ => base64)
    const fileToBase64 = (file) => new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result.split(',')[1]);
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });

    $('#callVoice').addEventListener('click', async () => {
      const f = $('#audioFile').files[0];
      const userId = $('#userId').value.trim() || 'test_user';
      if (!f) return setOutput('ì˜¤ë””ì˜¤ íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”.');
      try {
        const base64 = await fileToBase64(f);
        const res = await fetch('/api/chatbot/voice', {
          method: 'POST',
          headers: buildHeaders(true),
          body: JSON.stringify({ audioBuffer: base64, userId })
        });
        const data = await res.json();
        setOutput(data);
        showNavHint(data);
      } catch (e) {
        console.error('[callVoice] error', e);
        setOutput({ error: e.message });
      }
    });
  </script>
  <script>
    // ì‹¤ì‹œê°„ ìŒì„±(WebSocket + MediaRecorder)
    let ws = null;
    let mediaRecorder = null;
    let wsReady = false;

    function connectWs() {
      return new Promise((resolve, reject) => {
        ws = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws/speech');
        ws.onopen = () => { console.log('[WS] open'); resolve(); };
        ws.onerror = (e) => { console.error('[WS] error', e); reject(e); };
        ws.onclose = (e) => { console.warn('[WS] close', e?.code, e?.reason); };
        ws.onmessage = (evt) => {
          try {
            const msg = JSON.parse(evt.data);
            if (msg.type === 'ready') wsReady = true;
            if (msg.type === 'partial') setOutput({ partial: msg.text });
            if (msg.type === 'final') setOutput({ final: msg.text });
            if (msg.type === 'chatbot') { console.log('[WS] chatbot', msg.data); setOutput({ chatbot: msg.data }); showNavHint(msg.data); }
            if (msg.type === 'error') { console.error('[WS] server error', msg.message); setOutput({ error: msg.message }); }
          } catch {}
        };
      });
    }

    async function startRealtime() {
      try {
        await connectWs();
        const token = document.querySelector('#token').value.replace(/\s+/g, '').trim();
        // ë¸Œë¼ìš°ì €ê°€ ì§€ì›í•˜ëŠ” ì½”ë± ìë™ í˜‘ìƒ
        const candidates = [
          'audio/ogg;codecs=opus',
          'audio/webm;codecs=opus',
          'audio/webm',
          'audio/mp4',
          ''
        ];
        let selectedMime = '';
        for (const cand of candidates) {
          if (!cand || (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(cand))) {
            selectedMime = cand;
            break;
          }
        }
        if (!selectedMime) selectedMime = '';
        console.log('[Media] selected mime', selectedMime || '(browser default)');

        ws.send(JSON.stringify({ type: 'start', token, userId: document.querySelector('#userId').value.trim() || 'test_user', language: 'ko-KR', mime: selectedMime || 'audio/webm' }));

        // ë§ˆì´í¬ ê¶Œì¥ ì˜µì…˜(ë°˜í–¥ ì œê±°/ì†ŒìŒ ì–µì œ)
        const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true, channelCount: 1 } }).catch(err => { console.error('[Media] getUserMedia error', err); throw err; });
        mediaRecorder = selectedMime ? new MediaRecorder(stream, { mimeType: selectedMime }) : new MediaRecorder(stream);
        mediaRecorder.onstart = () => console.log('[Media] recorder start');
        mediaRecorder.onstop = () => console.log('[Media] recorder stop');
        mediaRecorder.onerror = (e) => console.error('[Media] recorder error', e);
        mediaRecorder.ondataavailable = async (e) => {
          if (e.data && e.data.size > 0 && ws && ws.readyState === 1) {
            const buf = await e.data.arrayBuffer();
            const b64 = btoa(String.fromCharCode(...new Uint8Array(buf)));
            console.log('[Media] chunk bytes', buf.byteLength);
            ws.send(JSON.stringify({ type: 'audio', chunk: b64 }));
          }
        };
        mediaRecorder.start(250); // ë” ë¹ ë¥¸ ë¶€ë¶„ ì¸ì‹
      } catch (e) { setOutput({ error: 'ë§ˆì´í¬ ì‹œì‘ ì‹¤íŒ¨: ' + (e?.message || e) }); }
    }

    async function stopRealtime() {
      try {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
        if (ws && ws.readyState === 1) ws.send(JSON.stringify({ type: 'stop' }));
        if (ws) ws.close();
        ws = null; mediaRecorder = null; wsReady = false;
      } catch {}
    }

    document.querySelector('#wsStart').addEventListener('click', startRealtime);
    document.querySelector('#wsStop').addEventListener('click', stopRealtime);

    // ì „ì—­ ì˜¤ë¥˜ ë¡œê¹…
    window.addEventListener('error', (e) => {
      console.error('[Global] error', e?.error || e?.message || e);
    });
    window.addEventListener('unhandledrejection', (e) => {
      console.error('[Global] unhandledrejection', e?.reason || e);
    });
  </script>
</body>
</html>
